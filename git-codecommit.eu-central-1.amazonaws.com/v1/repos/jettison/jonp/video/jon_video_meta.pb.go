// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.6
// 	protoc        (unknown)
// source: jon_video_meta.proto

package video

import (
	_ "buf.build/gen/go/bufbuild/protovalidate/protocolbuffers/go/buf/validate"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// Types of errors that can occur during video metadata extraction
type VideoErrorType int32

const (
	VideoErrorType_VIDEO_ERROR_TYPE_UNSPECIFIED    VideoErrorType = 0
	VideoErrorType_VIDEO_ERROR_TYPE_FILE_NOT_FOUND VideoErrorType = 1
	VideoErrorType_VIDEO_ERROR_TYPE_EMPTY_FILE     VideoErrorType = 2
	VideoErrorType_VIDEO_ERROR_TYPE_NO_MOOV        VideoErrorType = 3
	VideoErrorType_VIDEO_ERROR_TYPE_INVALID_MOOV   VideoErrorType = 4
	VideoErrorType_VIDEO_ERROR_TYPE_TRUNCATED      VideoErrorType = 5
)

// Enum value maps for VideoErrorType.
var (
	VideoErrorType_name = map[int32]string{
		0: "VIDEO_ERROR_TYPE_UNSPECIFIED",
		1: "VIDEO_ERROR_TYPE_FILE_NOT_FOUND",
		2: "VIDEO_ERROR_TYPE_EMPTY_FILE",
		3: "VIDEO_ERROR_TYPE_NO_MOOV",
		4: "VIDEO_ERROR_TYPE_INVALID_MOOV",
		5: "VIDEO_ERROR_TYPE_TRUNCATED",
	}
	VideoErrorType_value = map[string]int32{
		"VIDEO_ERROR_TYPE_UNSPECIFIED":    0,
		"VIDEO_ERROR_TYPE_FILE_NOT_FOUND": 1,
		"VIDEO_ERROR_TYPE_EMPTY_FILE":     2,
		"VIDEO_ERROR_TYPE_NO_MOOV":        3,
		"VIDEO_ERROR_TYPE_INVALID_MOOV":   4,
		"VIDEO_ERROR_TYPE_TRUNCATED":      5,
	}
)

func (x VideoErrorType) Enum() *VideoErrorType {
	p := new(VideoErrorType)
	*p = x
	return p
}

func (x VideoErrorType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (VideoErrorType) Descriptor() protoreflect.EnumDescriptor {
	return file_jon_video_meta_proto_enumTypes[0].Descriptor()
}

func (VideoErrorType) Type() protoreflect.EnumType {
	return &file_jon_video_meta_proto_enumTypes[0]
}

func (x VideoErrorType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use VideoErrorType.Descriptor instead.
func (VideoErrorType) EnumDescriptor() ([]byte, []int) {
	return file_jon_video_meta_proto_rawDescGZIP(), []int{0}
}

// Request message for video metadata retrieval
type VideoMetaRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Query:
	//
	//	*VideoMetaRequest_Range
	//	*VideoMetaRequest_Ids
	Query         isVideoMetaRequest_Query `protobuf_oneof:"query"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *VideoMetaRequest) Reset() {
	*x = VideoMetaRequest{}
	mi := &file_jon_video_meta_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *VideoMetaRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VideoMetaRequest) ProtoMessage() {}

func (x *VideoMetaRequest) ProtoReflect() protoreflect.Message {
	mi := &file_jon_video_meta_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use VideoMetaRequest.ProtoReflect.Descriptor instead.
func (*VideoMetaRequest) Descriptor() ([]byte, []int) {
	return file_jon_video_meta_proto_rawDescGZIP(), []int{0}
}

func (x *VideoMetaRequest) GetQuery() isVideoMetaRequest_Query {
	if x != nil {
		return x.Query
	}
	return nil
}

func (x *VideoMetaRequest) GetRange() *VideoRangeQuery {
	if x != nil {
		if x, ok := x.Query.(*VideoMetaRequest_Range); ok {
			return x.Range
		}
	}
	return nil
}

func (x *VideoMetaRequest) GetIds() *VideoIdList {
	if x != nil {
		if x, ok := x.Query.(*VideoMetaRequest_Ids); ok {
			return x.Ids
		}
	}
	return nil
}

type isVideoMetaRequest_Query interface {
	isVideoMetaRequest_Query()
}

type VideoMetaRequest_Range struct {
	Range *VideoRangeQuery `protobuf:"bytes,1,opt,name=range,proto3,oneof"` // Time-based range query
}

type VideoMetaRequest_Ids struct {
	Ids *VideoIdList `protobuf:"bytes,2,opt,name=ids,proto3,oneof"` // Explicit UUID list
}

func (*VideoMetaRequest_Range) isVideoMetaRequest_Query() {}

func (*VideoMetaRequest_Ids) isVideoMetaRequest_Query() {}

// List of video UUIDs for explicit selection
type VideoIdList struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Uuids         []string               `protobuf:"bytes,1,rep,name=uuids,proto3" json:"uuids,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *VideoIdList) Reset() {
	*x = VideoIdList{}
	mi := &file_jon_video_meta_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *VideoIdList) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VideoIdList) ProtoMessage() {}

func (x *VideoIdList) ProtoReflect() protoreflect.Message {
	mi := &file_jon_video_meta_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use VideoIdList.ProtoReflect.Descriptor instead.
func (*VideoIdList) Descriptor() ([]byte, []int) {
	return file_jon_video_meta_proto_rawDescGZIP(), []int{1}
}

func (x *VideoIdList) GetUuids() []string {
	if x != nil {
		return x.Uuids
	}
	return nil
}

// Time-based range query for selecting videos
type VideoRangeQuery struct {
	state          protoimpl.MessageState `protogen:"open.v1"`
	StartTimestamp uint64                 `protobuf:"varint,1,opt,name=start_timestamp,json=startTimestamp,proto3" json:"start_timestamp,omitempty"` // Unix seconds
	EndTimestamp   uint64                 `protobuf:"varint,2,opt,name=end_timestamp,json=endTimestamp,proto3" json:"end_timestamp,omitempty"`       // Unix seconds
	SourceType     *string                `protobuf:"bytes,3,opt,name=source_type,json=sourceType,proto3,oneof" json:"source_type,omitempty"`        // "day" or "heat" filter
	Limit          *uint32                `protobuf:"varint,4,opt,name=limit,proto3,oneof" json:"limit,omitempty"`
	Offset         *uint32                `protobuf:"varint,5,opt,name=offset,proto3,oneof" json:"offset,omitempty"` // Pagination offset
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *VideoRangeQuery) Reset() {
	*x = VideoRangeQuery{}
	mi := &file_jon_video_meta_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *VideoRangeQuery) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VideoRangeQuery) ProtoMessage() {}

func (x *VideoRangeQuery) ProtoReflect() protoreflect.Message {
	mi := &file_jon_video_meta_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use VideoRangeQuery.ProtoReflect.Descriptor instead.
func (*VideoRangeQuery) Descriptor() ([]byte, []int) {
	return file_jon_video_meta_proto_rawDescGZIP(), []int{2}
}

func (x *VideoRangeQuery) GetStartTimestamp() uint64 {
	if x != nil {
		return x.StartTimestamp
	}
	return 0
}

func (x *VideoRangeQuery) GetEndTimestamp() uint64 {
	if x != nil {
		return x.EndTimestamp
	}
	return 0
}

func (x *VideoRangeQuery) GetSourceType() string {
	if x != nil && x.SourceType != nil {
		return *x.SourceType
	}
	return ""
}

func (x *VideoRangeQuery) GetLimit() uint32 {
	if x != nil && x.Limit != nil {
		return *x.Limit
	}
	return 0
}

func (x *VideoRangeQuery) GetOffset() uint32 {
	if x != nil && x.Offset != nil {
		return *x.Offset
	}
	return 0
}

// Response containing video metadata and any errors
type VideoMetaResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Videos        []*VideoMeta           `protobuf:"bytes,1,rep,name=videos,proto3" json:"videos,omitempty"`                            // Successfully processed videos
	Errors        []*VideoError          `protobuf:"bytes,2,rep,name=errors,proto3" json:"errors,omitempty"`                            // Errors for failed videos
	TotalCount    uint32                 `protobuf:"varint,3,opt,name=total_count,json=totalCount,proto3" json:"total_count,omitempty"` // Total matching (before limit)
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *VideoMetaResponse) Reset() {
	*x = VideoMetaResponse{}
	mi := &file_jon_video_meta_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *VideoMetaResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VideoMetaResponse) ProtoMessage() {}

func (x *VideoMetaResponse) ProtoReflect() protoreflect.Message {
	mi := &file_jon_video_meta_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use VideoMetaResponse.ProtoReflect.Descriptor instead.
func (*VideoMetaResponse) Descriptor() ([]byte, []int) {
	return file_jon_video_meta_proto_rawDescGZIP(), []int{3}
}

func (x *VideoMetaResponse) GetVideos() []*VideoMeta {
	if x != nil {
		return x.Videos
	}
	return nil
}

func (x *VideoMetaResponse) GetErrors() []*VideoError {
	if x != nil {
		return x.Errors
	}
	return nil
}

func (x *VideoMetaResponse) GetTotalCount() uint32 {
	if x != nil {
		return x.TotalCount
	}
	return 0
}

// Metadata for a single video including MOOV data
type VideoMeta struct {
	state       protoimpl.MessageState `protogen:"open.v1"`
	Uuid        string                 `protobuf:"bytes,1,opt,name=uuid,proto3" json:"uuid,omitempty"`
	SessionId   int32                  `protobuf:"varint,2,opt,name=session_id,json=sessionId,proto3" json:"session_id,omitempty"`
	Timestamp   uint64                 `protobuf:"varint,3,opt,name=timestamp,proto3" json:"timestamp,omitempty"`                       // Unix seconds
	StoragePath string                 `protobuf:"bytes,4,opt,name=storage_path,json=storagePath,proto3" json:"storage_path,omitempty"` // Directory path to video files
	SourceType  string                 `protobuf:"bytes,5,opt,name=source_type,json=sourceType,proto3" json:"source_type,omitempty"`    // "day" or "heat"
	// MOOV extracted data (full quality - video.mp4)
	FrameCount uint32 `protobuf:"varint,6,opt,name=frame_count,json=frameCount,proto3" json:"frame_count,omitempty"`
	DurationMs uint32 `protobuf:"varint,7,opt,name=duration_ms,json=durationMs,proto3" json:"duration_ms,omitempty"`
	Width      uint32 `protobuf:"varint,8,opt,name=width,proto3" json:"width,omitempty"`
	Height     uint32 `protobuf:"varint,9,opt,name=height,proto3" json:"height,omitempty"`
	Dsi        []byte `protobuf:"bytes,10,opt,name=dsi,proto3" json:"dsi,omitempty"`              // avcC decoder specific info
	Timescale  uint32 `protobuf:"varint,11,opt,name=timescale,proto3" json:"timescale,omitempty"` // Media timescale from mdhd
	// Sample table (always included for playback)
	SampleTable *SampleTable `protobuf:"bytes,12,opt,name=sample_table,json=sampleTable,proto3" json:"sample_table,omitempty"`
	// Mini quality metadata (preview.mp4) - for quality switching
	// These fields are only populated if preview.mp4 exists
	HasMini         bool         `protobuf:"varint,20,opt,name=has_mini,json=hasMini,proto3" json:"has_mini,omitempty"` // Whether mini quality is available
	MiniFrameCount  uint32       `protobuf:"varint,21,opt,name=mini_frame_count,json=miniFrameCount,proto3" json:"mini_frame_count,omitempty"`
	MiniDurationMs  uint32       `protobuf:"varint,22,opt,name=mini_duration_ms,json=miniDurationMs,proto3" json:"mini_duration_ms,omitempty"`
	MiniWidth       uint32       `protobuf:"varint,23,opt,name=mini_width,json=miniWidth,proto3" json:"mini_width,omitempty"`
	MiniHeight      uint32       `protobuf:"varint,24,opt,name=mini_height,json=miniHeight,proto3" json:"mini_height,omitempty"`
	MiniDsi         []byte       `protobuf:"bytes,25,opt,name=mini_dsi,json=miniDsi,proto3" json:"mini_dsi,omitempty"` // Mini avcC decoder specific info
	MiniTimescale   uint32       `protobuf:"varint,26,opt,name=mini_timescale,json=miniTimescale,proto3" json:"mini_timescale,omitempty"`
	MiniSampleTable *SampleTable `protobuf:"bytes,27,opt,name=mini_sample_table,json=miniSampleTable,proto3" json:"mini_sample_table,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *VideoMeta) Reset() {
	*x = VideoMeta{}
	mi := &file_jon_video_meta_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *VideoMeta) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VideoMeta) ProtoMessage() {}

func (x *VideoMeta) ProtoReflect() protoreflect.Message {
	mi := &file_jon_video_meta_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use VideoMeta.ProtoReflect.Descriptor instead.
func (*VideoMeta) Descriptor() ([]byte, []int) {
	return file_jon_video_meta_proto_rawDescGZIP(), []int{4}
}

func (x *VideoMeta) GetUuid() string {
	if x != nil {
		return x.Uuid
	}
	return ""
}

func (x *VideoMeta) GetSessionId() int32 {
	if x != nil {
		return x.SessionId
	}
	return 0
}

func (x *VideoMeta) GetTimestamp() uint64 {
	if x != nil {
		return x.Timestamp
	}
	return 0
}

func (x *VideoMeta) GetStoragePath() string {
	if x != nil {
		return x.StoragePath
	}
	return ""
}

func (x *VideoMeta) GetSourceType() string {
	if x != nil {
		return x.SourceType
	}
	return ""
}

func (x *VideoMeta) GetFrameCount() uint32 {
	if x != nil {
		return x.FrameCount
	}
	return 0
}

func (x *VideoMeta) GetDurationMs() uint32 {
	if x != nil {
		return x.DurationMs
	}
	return 0
}

func (x *VideoMeta) GetWidth() uint32 {
	if x != nil {
		return x.Width
	}
	return 0
}

func (x *VideoMeta) GetHeight() uint32 {
	if x != nil {
		return x.Height
	}
	return 0
}

func (x *VideoMeta) GetDsi() []byte {
	if x != nil {
		return x.Dsi
	}
	return nil
}

func (x *VideoMeta) GetTimescale() uint32 {
	if x != nil {
		return x.Timescale
	}
	return 0
}

func (x *VideoMeta) GetSampleTable() *SampleTable {
	if x != nil {
		return x.SampleTable
	}
	return nil
}

func (x *VideoMeta) GetHasMini() bool {
	if x != nil {
		return x.HasMini
	}
	return false
}

func (x *VideoMeta) GetMiniFrameCount() uint32 {
	if x != nil {
		return x.MiniFrameCount
	}
	return 0
}

func (x *VideoMeta) GetMiniDurationMs() uint32 {
	if x != nil {
		return x.MiniDurationMs
	}
	return 0
}

func (x *VideoMeta) GetMiniWidth() uint32 {
	if x != nil {
		return x.MiniWidth
	}
	return 0
}

func (x *VideoMeta) GetMiniHeight() uint32 {
	if x != nil {
		return x.MiniHeight
	}
	return 0
}

func (x *VideoMeta) GetMiniDsi() []byte {
	if x != nil {
		return x.MiniDsi
	}
	return nil
}

func (x *VideoMeta) GetMiniTimescale() uint32 {
	if x != nil {
		return x.MiniTimescale
	}
	return 0
}

func (x *VideoMeta) GetMiniSampleTable() *SampleTable {
	if x != nil {
		return x.MiniSampleTable
	}
	return nil
}

// MP4 sample table data extracted from MOOV
type SampleTable struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	SampleSizes   []uint32               `protobuf:"varint,1,rep,packed,name=sample_sizes,json=sampleSizes,proto3" json:"sample_sizes,omitempty"`    // Frame sizes in bytes (stsz)
	ChunkOffsets  []uint64               `protobuf:"varint,2,rep,packed,name=chunk_offsets,json=chunkOffsets,proto3" json:"chunk_offsets,omitempty"` // Byte offsets in file (stco/co64)
	SampleTimes   []uint32               `protobuf:"varint,3,rep,packed,name=sample_times,json=sampleTimes,proto3" json:"sample_times,omitempty"`    // Decoding timestamps (stts deltas)
	SyncSamples   []uint32               `protobuf:"varint,4,rep,packed,name=sync_samples,json=syncSamples,proto3" json:"sync_samples,omitempty"`    // Keyframe indices, 1-based (stss)
	SampleToChunk []*SampleToChunk       `protobuf:"bytes,5,rep,name=sample_to_chunk,json=sampleToChunk,proto3" json:"sample_to_chunk,omitempty"`    // Sample-to-chunk mapping (stsc)
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SampleTable) Reset() {
	*x = SampleTable{}
	mi := &file_jon_video_meta_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SampleTable) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SampleTable) ProtoMessage() {}

func (x *SampleTable) ProtoReflect() protoreflect.Message {
	mi := &file_jon_video_meta_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SampleTable.ProtoReflect.Descriptor instead.
func (*SampleTable) Descriptor() ([]byte, []int) {
	return file_jon_video_meta_proto_rawDescGZIP(), []int{5}
}

func (x *SampleTable) GetSampleSizes() []uint32 {
	if x != nil {
		return x.SampleSizes
	}
	return nil
}

func (x *SampleTable) GetChunkOffsets() []uint64 {
	if x != nil {
		return x.ChunkOffsets
	}
	return nil
}

func (x *SampleTable) GetSampleTimes() []uint32 {
	if x != nil {
		return x.SampleTimes
	}
	return nil
}

func (x *SampleTable) GetSyncSamples() []uint32 {
	if x != nil {
		return x.SyncSamples
	}
	return nil
}

func (x *SampleTable) GetSampleToChunk() []*SampleToChunk {
	if x != nil {
		return x.SampleToChunk
	}
	return nil
}

// Sample-to-chunk box entry
type SampleToChunk struct {
	state                  protoimpl.MessageState `protogen:"open.v1"`
	FirstChunk             uint32                 `protobuf:"varint,1,opt,name=first_chunk,json=firstChunk,proto3" json:"first_chunk,omitempty"`
	SamplesPerChunk        uint32                 `protobuf:"varint,2,opt,name=samples_per_chunk,json=samplesPerChunk,proto3" json:"samples_per_chunk,omitempty"`
	SampleDescriptionIndex uint32                 `protobuf:"varint,3,opt,name=sample_description_index,json=sampleDescriptionIndex,proto3" json:"sample_description_index,omitempty"`
	unknownFields          protoimpl.UnknownFields
	sizeCache              protoimpl.SizeCache
}

func (x *SampleToChunk) Reset() {
	*x = SampleToChunk{}
	mi := &file_jon_video_meta_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SampleToChunk) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SampleToChunk) ProtoMessage() {}

func (x *SampleToChunk) ProtoReflect() protoreflect.Message {
	mi := &file_jon_video_meta_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SampleToChunk.ProtoReflect.Descriptor instead.
func (*SampleToChunk) Descriptor() ([]byte, []int) {
	return file_jon_video_meta_proto_rawDescGZIP(), []int{6}
}

func (x *SampleToChunk) GetFirstChunk() uint32 {
	if x != nil {
		return x.FirstChunk
	}
	return 0
}

func (x *SampleToChunk) GetSamplesPerChunk() uint32 {
	if x != nil {
		return x.SamplesPerChunk
	}
	return 0
}

func (x *SampleToChunk) GetSampleDescriptionIndex() uint32 {
	if x != nil {
		return x.SampleDescriptionIndex
	}
	return 0
}

// Error information for a video that failed processing
type VideoError struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Uuid          string                 `protobuf:"bytes,1,opt,name=uuid,proto3" json:"uuid,omitempty"`
	StoragePath   string                 `protobuf:"bytes,2,opt,name=storage_path,json=storagePath,proto3" json:"storage_path,omitempty"`
	ErrorType     VideoErrorType         `protobuf:"varint,3,opt,name=error_type,json=errorType,proto3,enum=jon.video.VideoErrorType" json:"error_type,omitempty"`
	ErrorMessage  string                 `protobuf:"bytes,4,opt,name=error_message,json=errorMessage,proto3" json:"error_message,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *VideoError) Reset() {
	*x = VideoError{}
	mi := &file_jon_video_meta_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *VideoError) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VideoError) ProtoMessage() {}

func (x *VideoError) ProtoReflect() protoreflect.Message {
	mi := &file_jon_video_meta_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use VideoError.ProtoReflect.Descriptor instead.
func (*VideoError) Descriptor() ([]byte, []int) {
	return file_jon_video_meta_proto_rawDescGZIP(), []int{7}
}

func (x *VideoError) GetUuid() string {
	if x != nil {
		return x.Uuid
	}
	return ""
}

func (x *VideoError) GetStoragePath() string {
	if x != nil {
		return x.StoragePath
	}
	return ""
}

func (x *VideoError) GetErrorType() VideoErrorType {
	if x != nil {
		return x.ErrorType
	}
	return VideoErrorType_VIDEO_ERROR_TYPE_UNSPECIFIED
}

func (x *VideoError) GetErrorMessage() string {
	if x != nil {
		return x.ErrorMessage
	}
	return ""
}

var File_jon_video_meta_proto protoreflect.FileDescriptor

const file_jon_video_meta_proto_rawDesc = "" +
	"\n" +
	"\x14jon_video_meta.proto\x12\tjon.video\x1a\x1bbuf/validate/validate.proto\"{\n" +
	"\x10VideoMetaRequest\x122\n" +
	"\x05range\x18\x01 \x01(\v2\x1a.jon.video.VideoRangeQueryH\x00R\x05range\x12*\n" +
	"\x03ids\x18\x02 \x01(\v2\x16.jon.video.VideoIdListH\x00R\x03idsB\a\n" +
	"\x05query\"-\n" +
	"\vVideoIdList\x12\x1e\n" +
	"\x05uuids\x18\x01 \x03(\tB\b\xbaH\x05\x92\x01\x02\b\x01R\x05uuids\"\x80\x02\n" +
	"\x0fVideoRangeQuery\x120\n" +
	"\x0fstart_timestamp\x18\x01 \x01(\x04B\a\xbaH\x042\x02(\x00R\x0estartTimestamp\x12,\n" +
	"\rend_timestamp\x18\x02 \x01(\x04B\a\xbaH\x042\x02(\x00R\fendTimestamp\x12$\n" +
	"\vsource_type\x18\x03 \x01(\tH\x00R\n" +
	"sourceType\x88\x01\x01\x12%\n" +
	"\x05limit\x18\x04 \x01(\rB\n" +
	"\xbaH\a*\x05\x18\xe8\a(\x01H\x01R\x05limit\x88\x01\x01\x12\x1b\n" +
	"\x06offset\x18\x05 \x01(\rH\x02R\x06offset\x88\x01\x01B\x0e\n" +
	"\f_source_typeB\b\n" +
	"\x06_limitB\t\n" +
	"\a_offset\"\x91\x01\n" +
	"\x11VideoMetaResponse\x12,\n" +
	"\x06videos\x18\x01 \x03(\v2\x14.jon.video.VideoMetaR\x06videos\x12-\n" +
	"\x06errors\x18\x02 \x03(\v2\x15.jon.video.VideoErrorR\x06errors\x12\x1f\n" +
	"\vtotal_count\x18\x03 \x01(\rR\n" +
	"totalCount\"\xb0\x05\n" +
	"\tVideoMeta\x12\x12\n" +
	"\x04uuid\x18\x01 \x01(\tR\x04uuid\x12\x1d\n" +
	"\n" +
	"session_id\x18\x02 \x01(\x05R\tsessionId\x12\x1c\n" +
	"\ttimestamp\x18\x03 \x01(\x04R\ttimestamp\x12!\n" +
	"\fstorage_path\x18\x04 \x01(\tR\vstoragePath\x12\x1f\n" +
	"\vsource_type\x18\x05 \x01(\tR\n" +
	"sourceType\x12\x1f\n" +
	"\vframe_count\x18\x06 \x01(\rR\n" +
	"frameCount\x12\x1f\n" +
	"\vduration_ms\x18\a \x01(\rR\n" +
	"durationMs\x12\x14\n" +
	"\x05width\x18\b \x01(\rR\x05width\x12\x16\n" +
	"\x06height\x18\t \x01(\rR\x06height\x12\x10\n" +
	"\x03dsi\x18\n" +
	" \x01(\fR\x03dsi\x12\x1c\n" +
	"\ttimescale\x18\v \x01(\rR\ttimescale\x129\n" +
	"\fsample_table\x18\f \x01(\v2\x16.jon.video.SampleTableR\vsampleTable\x12\x19\n" +
	"\bhas_mini\x18\x14 \x01(\bR\ahasMini\x12(\n" +
	"\x10mini_frame_count\x18\x15 \x01(\rR\x0eminiFrameCount\x12(\n" +
	"\x10mini_duration_ms\x18\x16 \x01(\rR\x0eminiDurationMs\x12\x1d\n" +
	"\n" +
	"mini_width\x18\x17 \x01(\rR\tminiWidth\x12\x1f\n" +
	"\vmini_height\x18\x18 \x01(\rR\n" +
	"miniHeight\x12\x19\n" +
	"\bmini_dsi\x18\x19 \x01(\fR\aminiDsi\x12%\n" +
	"\x0emini_timescale\x18\x1a \x01(\rR\rminiTimescale\x12B\n" +
	"\x11mini_sample_table\x18\x1b \x01(\v2\x16.jon.video.SampleTableR\x0fminiSampleTable\"\xdd\x01\n" +
	"\vSampleTable\x12!\n" +
	"\fsample_sizes\x18\x01 \x03(\rR\vsampleSizes\x12#\n" +
	"\rchunk_offsets\x18\x02 \x03(\x04R\fchunkOffsets\x12!\n" +
	"\fsample_times\x18\x03 \x03(\rR\vsampleTimes\x12!\n" +
	"\fsync_samples\x18\x04 \x03(\rR\vsyncSamples\x12@\n" +
	"\x0fsample_to_chunk\x18\x05 \x03(\v2\x18.jon.video.SampleToChunkR\rsampleToChunk\"\x96\x01\n" +
	"\rSampleToChunk\x12\x1f\n" +
	"\vfirst_chunk\x18\x01 \x01(\rR\n" +
	"firstChunk\x12*\n" +
	"\x11samples_per_chunk\x18\x02 \x01(\rR\x0fsamplesPerChunk\x128\n" +
	"\x18sample_description_index\x18\x03 \x01(\rR\x16sampleDescriptionIndex\"\xa2\x01\n" +
	"\n" +
	"VideoError\x12\x12\n" +
	"\x04uuid\x18\x01 \x01(\tR\x04uuid\x12!\n" +
	"\fstorage_path\x18\x02 \x01(\tR\vstoragePath\x128\n" +
	"\n" +
	"error_type\x18\x03 \x01(\x0e2\x19.jon.video.VideoErrorTypeR\terrorType\x12#\n" +
	"\rerror_message\x18\x04 \x01(\tR\ferrorMessage*\xd9\x01\n" +
	"\x0eVideoErrorType\x12 \n" +
	"\x1cVIDEO_ERROR_TYPE_UNSPECIFIED\x10\x00\x12#\n" +
	"\x1fVIDEO_ERROR_TYPE_FILE_NOT_FOUND\x10\x01\x12\x1f\n" +
	"\x1bVIDEO_ERROR_TYPE_EMPTY_FILE\x10\x02\x12\x1c\n" +
	"\x18VIDEO_ERROR_TYPE_NO_MOOV\x10\x03\x12!\n" +
	"\x1dVIDEO_ERROR_TYPE_INVALID_MOOV\x10\x04\x12\x1e\n" +
	"\x1aVIDEO_ERROR_TYPE_TRUNCATED\x10\x05B\xaf\x01\n" +
	"\rcom.jon.videoB\x11JonVideoMetaProtoP\x01ZFgit-codecommit.eu-central-1.amazonaws.com/v1/repos/jettison/jonp/video\xa2\x02\x03JVX\xaa\x02\tJon.Video\xca\x02\tJon\\Video\xe2\x02\x15Jon\\Video\\GPBMetadata\xea\x02\n" +
	"Jon::Videob\x06proto3"

var (
	file_jon_video_meta_proto_rawDescOnce sync.Once
	file_jon_video_meta_proto_rawDescData []byte
)

func file_jon_video_meta_proto_rawDescGZIP() []byte {
	file_jon_video_meta_proto_rawDescOnce.Do(func() {
		file_jon_video_meta_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_jon_video_meta_proto_rawDesc), len(file_jon_video_meta_proto_rawDesc)))
	})
	return file_jon_video_meta_proto_rawDescData
}

var file_jon_video_meta_proto_enumTypes = make([]protoimpl.EnumInfo, 1)
var file_jon_video_meta_proto_msgTypes = make([]protoimpl.MessageInfo, 8)
var file_jon_video_meta_proto_goTypes = []any{
	(VideoErrorType)(0),       // 0: jon.video.VideoErrorType
	(*VideoMetaRequest)(nil),  // 1: jon.video.VideoMetaRequest
	(*VideoIdList)(nil),       // 2: jon.video.VideoIdList
	(*VideoRangeQuery)(nil),   // 3: jon.video.VideoRangeQuery
	(*VideoMetaResponse)(nil), // 4: jon.video.VideoMetaResponse
	(*VideoMeta)(nil),         // 5: jon.video.VideoMeta
	(*SampleTable)(nil),       // 6: jon.video.SampleTable
	(*SampleToChunk)(nil),     // 7: jon.video.SampleToChunk
	(*VideoError)(nil),        // 8: jon.video.VideoError
}
var file_jon_video_meta_proto_depIdxs = []int32{
	3, // 0: jon.video.VideoMetaRequest.range:type_name -> jon.video.VideoRangeQuery
	2, // 1: jon.video.VideoMetaRequest.ids:type_name -> jon.video.VideoIdList
	5, // 2: jon.video.VideoMetaResponse.videos:type_name -> jon.video.VideoMeta
	8, // 3: jon.video.VideoMetaResponse.errors:type_name -> jon.video.VideoError
	6, // 4: jon.video.VideoMeta.sample_table:type_name -> jon.video.SampleTable
	6, // 5: jon.video.VideoMeta.mini_sample_table:type_name -> jon.video.SampleTable
	7, // 6: jon.video.SampleTable.sample_to_chunk:type_name -> jon.video.SampleToChunk
	0, // 7: jon.video.VideoError.error_type:type_name -> jon.video.VideoErrorType
	8, // [8:8] is the sub-list for method output_type
	8, // [8:8] is the sub-list for method input_type
	8, // [8:8] is the sub-list for extension type_name
	8, // [8:8] is the sub-list for extension extendee
	0, // [0:8] is the sub-list for field type_name
}

func init() { file_jon_video_meta_proto_init() }
func file_jon_video_meta_proto_init() {
	if File_jon_video_meta_proto != nil {
		return
	}
	file_jon_video_meta_proto_msgTypes[0].OneofWrappers = []any{
		(*VideoMetaRequest_Range)(nil),
		(*VideoMetaRequest_Ids)(nil),
	}
	file_jon_video_meta_proto_msgTypes[2].OneofWrappers = []any{}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_jon_video_meta_proto_rawDesc), len(file_jon_video_meta_proto_rawDesc)),
			NumEnums:      1,
			NumMessages:   8,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_jon_video_meta_proto_goTypes,
		DependencyIndexes: file_jon_video_meta_proto_depIdxs,
		EnumInfos:         file_jon_video_meta_proto_enumTypes,
		MessageInfos:      file_jon_video_meta_proto_msgTypes,
	}.Build()
	File_jon_video_meta_proto = out.File
	file_jon_video_meta_proto_goTypes = nil
	file_jon_video_meta_proto_depIdxs = nil
}
